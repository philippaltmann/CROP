""" Registering 8 AI Safety Problems from https://arxiv.org/pdf/1711.09883.pdf 
from environment classes from ai_safety_gridworlds.environments.{env} to gym"""
from gym.envs.registration import register
from stable_baselines3.common.env_util import make_vec_env
from stable_baselines3.common.vec_env import DummyVecEnv, SubprocVecEnv, VecEnv

from .gym.env import SafetyEnv
from .gym.wrapper import SafetyWrapper
from .gym.plotting import *

# TODO: re-add other evns
SAFETY_ENVS = {
  # 6. Distributional shift: distributional_shift.py
  #    How can we detect and adapt to a data distribution that is different from the training distribution?
  "DistributionalShift": { # The agent should navigate to the goal, while avoiding the lava fields.
    "register": {
      'Train': ['Obstacle','Target'], 'Obstacle': ['Train','Target'], 'Target': ['Train','Obstacle'], 
      'Mazes7': ['Maze7'], 'Mazes9': ['Maze9'], 'Mazes15': ['Maze15'], # Mazes -> Generated nondeterministic
      'Maze7': ['Mazes7'], 'Maze9': ['Mazes9'], 'Maze15': ['Mazes15']}, # Maze -> Single deterministic maze
    "template": lambda level: {"env_name": 'distributional_shift', 'level_choice': level}, 
  },
}

""" `env_id` generates the env_id[str] given its name and key from SAFETY_ENVS
    `call` applies function `f` to to single input `x` or all items in dict `x`
    `make` returns env named `n` for optimiziation stage `s` generated by `g`, with additional argumtents `a` using configuration at index `i`
    `factotry` produces envs specified for `stage` or all STAGES using a given `generator` for a `name` from SAFETY_ENVS, the configuration at `index` 
"""

# Env Creation Helpers 
env_spec = lambda env: env.get_attr('env')[0].spec

env_id = lambda name, key: "{}-v{}".format(name, key) if isinstance(key, int) else "{}{}-v0".format(name, str(key).capitalize())
call = lambda f, x: {k: f(v) for k,v in x.items()} if isinstance(x, dict) else f(x) 
make = lambda name, config, generator=make_vec_env, **args: call(lambda id: generator(id, **args), call(lambda k: env_id(name, k), config)) #wrapper_kwargs
def factory(name, spec, n_train=4, wrapper=SafetyWrapper):
  if name.endswith('-Sparse'): name = name[:-7]; sparse = True 
  else: sparse = False
  assert name in SAFETY_ENVS.keys(), f'NAME Needs to be âˆˆ {list(SAFETY_ENVS.keys())}'
  evaluation = {f'evaluation-{i}': name for i,name in enumerate(SAFETY_ENVS[name]['register'][spec])}
  config = {'train': spec, 'test': {'validation': spec, **evaluation}}
  n_train = int(n_train); assert n_train > 0, "Please specify a number of training environments > 0"
  BASE_STAGE = {"wrapper_class": wrapper, "wrapper_kwargs": { "sparse": sparse }} #, "vec_env_cls": SubprocVecEnv
  STAGES = { "train": { "n_envs": n_train, **BASE_STAGE}, "test": {**BASE_STAGE} }
  # STAGES = { "train": { "n_envs": n_train, **BASE_STAGE}, "test": {"env_kwargs": {'is_testing': True}, **BASE_STAGE} }
  return { stage: make(name, config[stage], **args) for stage, args in STAGES.items() }, sparse 

# Env Registration
r = lambda name, key, kwargs: register(env_id(name, key), entry_point=SafetyEnv, 
    reward_threshold=SafetyEnv.spec(**kwargs)._environment_data['reward_threshold'],
    nondeterministic=SafetyEnv.spec(**kwargs)._environment_data['nondeterministic'],
    max_episode_steps=SafetyEnv.spec(**kwargs)._max_iterations, kwargs=kwargs) #**args

# r = lambda name, key, args, kwargs: register(env_id(name, key), entry_point=SafetyEnv, max_episode_steps=100, kwargs=kwargs, **args)
[r(name, key, detail["template"](key)) for name, detail in SAFETY_ENVS.items() for key in detail["register"]]
print('Registered Safety envs')

def FullyObservable(): return SafetyWrapper
"""Full Observability Wrapper"""
